# [92344] 파괴되지 않은 건물
## Algorithm
- Prefix Sum
## Logic
모든 `skill`마다 `board`를 업데이트하면 비효율적이다. `board`의 크기 자체는 크지 않지만, `skill`의 최대 길이가 250,000이기 때문이다.
따라서, 업데이트를 마지막에 한 번에 할 수 있도록 '누적 합' 개념을 사용해 시작과 끝지점만 마크한다.

```js
const mark = (r1, c1, r2, c2, degree) => {
    prefixSum[r1 * M + c1] += degree;
    if(c2 + 1 < M) prefixSum[r1 * M + c2 + 1] += -1 * degree;
    if(r2 + 1 < N) prefixSum[(r2 + 1) * M + c1] += -1 * degree;
    if(c2 + 1 < M && r2 + 1 < N) prefixSum[(r2 + 1) * M + c2 + 1] += degree;
}
```

이차원 배열이기 때문에 열의 끝지점 뿐만 아니라 행의 끝지점, 행과 열의 끝지점도 마크 해줘야한다.

마지막 계산은 각 행에서 누적합, 각 열에서 누적합을 계산하고, 누적합을 board와 더해주면 전체 결과를 얻을 수 있다.

## Review
`skill`을 어떻게 처리하는지가 관건인 문제였다. 뭔가 구간 별로 처리하는 것에서 최적화 할 수 있다고는 생각했는데, 누적합은 생각하지 못했다.
구간을 트리로 표현하거나 `board`를 다른 자료형으로 표현할 수 있나 생각하다가 답을 봤다.

풀이를 보고나니 저번에 풀었던 '광고 삽입' 문제가 떠올랐다. 다음부터 구간별로 처리하는 문제를 만나면 꼭 누적합을 생각해보자.