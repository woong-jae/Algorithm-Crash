# [92345] 사라지는 발판

## Algorithm

- DFS

## Logic

A와 B가 서로 번갈아가며 현재 플레이어가 되어 DFS를 수행한다.

- **현재 플레이어 위치에 발판이 없거나, 더이상 이동할 수 없는 경우 게임에서 패배한다.**

  ```js
  // 현재 플레이어의 패배
  if (!board[x][y] || !nextPos.length) {
    return { isWin: false, cnt: 0 };
  }
  ```

  - `nextPos`는 상, 하, 좌, 우 중 이동 가능한 위치를 가진 배열이다.

  - 패배하였으므로 `{ 승리 여부: false, 이동 횟수: 0 }`을 반환한다.

- **패배하지 않았을 경우 `nextPos`를 순회하며 다음 턴, 즉 재귀 함수를 호출한다.**

  ```js
  const results = nextPos.map((pos) => playTurn(nextPlayer, pos));
  ```

  - 다음 턴을 수행하기 위해 현재 플레이어를 변경하여 호출한다.

- **다음 턴에서 반환된 상대방의 모든 결과 `results`를 순회하며 이동 횟수를 선정한다.**

  ```js
  let winCnt = 0;
  let max = 0;
  let min = Infinity;

  results.forEach((result) => {
    // 다음 턴에서 상대가 패배
    // - 현재 플레이어는 승리했으므로 최소한의 이동을 선택
    if (!result.isWin) {
      min = Math.min(min, result.cnt);
      return;
    }
    // 다음 턴에서 상대가 승리
    // - 현재 플레이어는 패배했으므로 최대한의 이동을 선택
    max = Math.max(max, result.cnt);
    winCnt++;
  });
  ```

  - 양 플레이어는 최적의 플레이를 해야한다.

    - 승리하는 플레이어는 최소한의 이동으로 승리해야 한다.

    - 패배하는 플레이어는 최대한의 이동으로 승리해야 한다.

  - 다음 턴에서 상대방이 패배한 경우, 현재 플레이어가 승리한 것이므로 최소한의 이동을 선택한다.

  - 다음 턴에서 상대방이 승리한 경우, 현재 플레이어가 패배한 것이므로 최대한의 이동을 선택한다.

- **현재 플레이어가 승리하는 플레이어인지, 패배하는 플레이어인지 선택한다.**

  '이길 수 있는 방법이 있는지', '질 수 밖에 없는지' 확인한다.

  ```js
  // 상대 턴으로 넘어간 모든 결과가 승리
  // = 현재 플레이어는 반드시 패배
  if (winCnt === results.length) {
    return { isWin: false, cnt: max + 1 };
  }

  // 상대 턴으로 넘어간 모든 결과 중 패배하는 경우 존재
  // = 현재 플레이어가 승리하는 경우 존재
  return { isWin: true, cnt: min + 1 };
  ```

  - 상대 턴으로 넘어간 모든 결과가 승리인 경우, 현재 플레이어는 반드시 패배한다.

    - 따라서 `{ 승리 여부: false, 이동 횟수: 최대한의 이동 + 현재 플레이어의 이동 }`을 반환한다.

  - 상대 턴으로 넘어간 모든 결과 중 패배하는 경우가 존재하면, 현재 플레이어는 승리를 선택한다.

    - 따라서 `{ 승리 여부: true, 이동 횟수: 최소한의 이동 + 현재 플레이어의 이동 }`을 반환한다.

### 시간 복잡도 : O(n^2)

## Review

양 플레이어가 최적의 플레이를 하는 것에 대한 아이디어를 떠올리지 못했다.

다른 사람의 코드를 참고하여 구현했지만.. 너무 어렵다...

오늘 하루 다 날렸다.