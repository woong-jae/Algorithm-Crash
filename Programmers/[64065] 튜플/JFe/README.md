# [64065] 튜플 - Python

## 🔍 Algorithm
**문자열**

## 💻 Logic

```Python
s_list = s.split('},{')     # '},{' 기준으로 문자열 나눔
for i in range(len(s_list)):
    s_list[i] = s_list[i].strip('{''}') # 문자열 양 끝마다 필요없는 괄호 제거
    s_list[i] = list(map(int, s_list[i].split(',')))    # ','를 기준으로 나누고 int로 변환해서 리스트 저장
s_list.sort(key=len)    # 길이 순서로 오름차순 정렬
```
- **`'},{'` 기준으로 문자열 나눔**  
    `','`를 기준으로 **split**하면 괄호 안의 `','` 기준으로도 같이 나뉘기 때문에  
    닫는 괄호와 여는 괄호를 포함한 `'},{'`를 기준으로 문자열을 나눠준다.  
- **split한 리스트마다 문자열 파싱**  
    먼저, 필요없는 괄호를 제거하기 위해 `strip` 함수를 이용해 문자열 양 끝에 있는 괄호들을 없애준다.  
    다음으로 `','`를 기준으로 나눠주고 **int형**으로 값을 저장하기 위해 `map`을 이용해 **int형**으로 변환해주고 리스트로 다시 저장한다.  
- **길이 순서로 오름차순 정렬**  
    길이 순서로 정렬해야지 제대로 된 튜플 답을 편하게 구할 수 있기 때문에 `key=len`을 이용해서 정렬해준다.  

```Python
# 리스트 반복문 돌면서 answer에 없는 값이면 answer에 추가 
for l in s_list:
    for n in l:
        if n not in answer: answer.append(n)
return answer
```
- **리스트 반복문 돌면서 answer에 없는 값이면 answer에 추가**  
    튜플에 값이 중복되지 않게 넣어야 되기 때문에 조건문을 통해 확인하고 `answer`에 **append** 해준다.  


## 📝 Review

튜플 원소 순서가 부분집합 크기 작은 것부터 중복되는 값을 포함 안 하면서 순서대로인 것을 찾고, 이에 맞게 문자열을 파싱하면서 구현했다.  
앞부분 테스트케이스들은 빠르게 처리되는데 뒷부분 테스트케이스들은 실행 시간이 급격히 늘어나는 걸 보니 더 효율적인 방법이 있을 것 같다,,  
