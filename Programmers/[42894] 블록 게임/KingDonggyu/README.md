# [42894] 블록 게임

## Algorithm

- ?

## Logic

```js
const blockPattern = [
  [[1, 0], [1, 1], [1, 2]],
  [[1, 0], [2, 0], [2, -1]],
  [[1, 0], [2, 0], [2, 1]],
  [[1, 0], [1, -1], [1, -2]],
  [[1, 0], [1, -1], [1, 1]],
];
```

- 없앨 수 있는 블록의 패턴 방향을 정의한다.

```js
const blockEmpty = [
  [[0, 1], [0, 2]],
  [[0, -1], [1, -1]],
  [[0, 1], [1, 1]],
  [[0, -1], [0, -2]],
  [[0, -1], [0, 1]]
];
```

- 없앨 수 있는 블록의 비어있는 부분 방향을 정의한다.

```js
board.forEach((row, x) => {
  row.forEach((block, y) => {
    if (block) {
      answer += removeBlocks(board, x, y);
    }
  })
  row.forEach((block, y) => {
    if (block) {
      answer += removeBlocks(board, x, y);
    }
  })
});
```

- 그런 다음 주어진 board를 순회한다. 

  - 이때 한 row를 두번 순회하는데, 그 이유는 없앨 수 있는 블록의 패턴이 뒤늦게 나올 수 있는 경우를 고려하기 위해서다.

- 순회하다 정의한 패턴에 맞는 블록을 발견했을 경우, 해당 블록의 위에 다른 블록이 있는지 확인한다.

  - 이때 정의한 블록의 비어있는 부분 방향을 이용하여 해당 위치의 column을 순회하여 확인한다.

  - 만약 다른 블록이 있으면 0을 리턴, 없으면 1을 리턴한다.

- 리턴된 수를 answer에 더한다.

### 시간 복잡도: O(N^2)

## Review

없앨 수 있는 블록의 패턴을 미리 정의하니 쉬웠다.

어떠한 알고리즘이나 자료구조를 쓰기보다는 단순 구현으로 해결했다.