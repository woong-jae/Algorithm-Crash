# [67259] 경주로 건설
## Algorithm
- BFS (+ DP?)
## Logic
1. BFS로 풀기 위해서 queue 선언하고 (ros, col, 방향, 현재 비용) 넣음
2. 최소비용을 구해야하니까, dp 배열 써야함 (+ 비용이랑 방향 둘 다 체크해야하므로 3차원 배열로 선언)
3. queue 있으면 반복문 돌면서 지금 위치에서 동서남북 다음 위치 체크
4. 다음 위치가 범위 안 & 벽 아니면?
```python
if 0 <= next_r < N and 0 <= next_c < N and board[next_r][next_c] == 0: # 다음칸이 벽 아니고 & 격자 안임
    if now_dir == next_dir: # 방향 같으면 100만 증가
        cost = 1 + now_cost
    else: # 90도 꺾이면 100 + 500 증가
        cost = 6 + now_cost

    if check[next_dir][next_r][next_c] > cost: # 더 작은 값 발생
        check[next_dir][next_r][next_c] = cost
        queue.append([next_r, next_c, next_dir, cost])
```
- 90도로 꺾는 경우면 현재비용 + 600, 같은 방향이면 + 100
- 이미 다음 위치에 저장돼있는 값보다 더 작은 경우가 발생했으면 지금 비용과 방향으로 갱신해줌
5. 4가지 방향의 경우에서 비용이 발생하므로, 4가지 중 최소값이 answer

- 시간복잡도 O(N^2)

## Review
처음에 그냥 단순히 2차원배열로 비용만 체크하니까 맨 마지막 테스트케이스를 통과 못해서 애먹었다;;</br>
알고보니 당장의 비용이 작은거로 갱신하면 안되는 경우 있었다.
> (예) [1, 1]의 경우, (남쪽, 비용 100)이 (동쪽, 200)보다 비용 작아서 [1, 1]칸은 (남쪽, 100)됨. 그런데 [1, 2] 칸으로 가면, (남쪽, 100)은 700인데 반해서 (동쪽, 200)은 300으로 더 작은 경우가 발생함.

그래서 비용 + 방향까지 저장하는 **3차원 배열** 사용해야했다.
다 풀고나서 느꼈는데, 백준 [4991] 로봇청소기 문제랑 비슷한 느낌이다. bfs + dp 문제들 복습해야겠음
