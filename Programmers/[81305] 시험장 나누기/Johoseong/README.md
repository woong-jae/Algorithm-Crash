# [81305] 시험장 나누기
## Algorithm
- Parametric Search, DFS
## Logic
- 각 그룹의 수를 제한할 때 필요한 수를 구하는게 핵심
- 그러기 위해선, 리프에서부터 올라가면서 왼쪽 자식/오른쪽 자식에서 오는 인원 수를 고려해줘야함
- 재귀로 트리 탐색해서 왼쪽/오른쪽 자식 인원 수 알 수 있음
```python
lv = 0
if l[cur] != -1: lv = dfs(l[cur], lim) # 왼쪽 자식 수
rv = 0
if r[cur] != -1: rv = dfs(r[cur], lim) # 오른쪽 자식 수
```
- 이 때 3가지 경우 발생
1. 왼쪽 자식 + 오른쪽 자식을 현재 노드 인원과 다 합해도 그룹 limit 이하
<br>현재 인원 + 왼쪽 자식 인원 + 오른쪽 자식 인원 합한 후 리턴
2. 왼쪽 자식, 오른쪽 자식 중 작은 인원을 현재 인원과 합하면 그룹 limit 이하
<br>현재 인원 + 두 자식 중 작은 인원 합한 후 리턴
3. 왼쪽 자식과 오른쪽 자식 아예 합할 수 없음. 초과 되는 경우
<br>이 경우에는 자식들을 따로 그룹을 생성해야함
```python
# 왼쪽 자식 트리와 오른쪽 자식 트리에서 넘어오는 인원을 모두 합해도 lim 이하일 경우
if x[cur] + lv + rv <= lim:
    return x[cur] + lv + rv
# 왼쪽 자식 트리와 오른쪽 자식 트리에서 넘어오는 인원 중 작은 것을 합해도 lim 이하일 경우
if x[cur] + min(lv, rv) <= lim:
    cnt += 1 # 둘 중 큰 인원은 그룹을 지어버림
    return x[cur] + min(lv, rv)

# 1, 2 둘 다 아닐 경우
cnt += 2 # 왼쪽 자식 트리와 오른쪽 자식 트리 각각을 따로 그룹을 만듬
```
- 시간복잡도 O(NlogN)..?

## Review
어떻게 풀지 감도 안잡혀서 찾아보니까 처음보는 알고리즘으로 푸는 문제였다.<br>
생소한 알고리즘이라서 코드 이해하는 데에도 시간이 오래 걸렸다.. 일단 해당 알고리즘을 쓰는 경우는 ```그룹의 수를 제한할 때 생기는 그룹의 수```를 구할 때 사용될 수 있는 것 같다. 쉬운거부터 풀어봐야겠다.
