# [67258] 보석 쇼핑
## Algorithm
- 투 포인터
## Logic
### 처음 풀이
- 처음에는 ```len(gems) * 보석종류```의 배열을 선언해서 풀었음.
- gems를 탐색하면서 배열에 각 보석의 시작 인덱스를 저장하고, 매번 제일 짧은 경우인지를 검사했음.
- 그런데 매번 제일 짧은 경우를 찾으니 O(N^2)이 나왔고, 효율성 통과 못했음.
### 투 포인터
1. 시작점과 끝점 인덱스를 저장하는 start, end 변수를 씀.
2. end를 이동하면서 gems를 탐색함.
3. 처음 발견하는 보석이면 딕셔너리에 추가하고, value는 발견횟수를 넣음. 처음 발견이면 1, 이미 딕셔너리에 있으면 +1.
4. 이 때 딕셔너리 길이와 보석 종류와 같다면? (즉, 보석을 종류별로 다 찾았다면?) 제일 짧은 범위를 찾아야함.
```python
if len(gem_dict) == gem_unique: # 보석 종류별로 다 찾았으면?
    while start < end: # 더 짧은 범위인지 검사함
        if gem_dict[gems[start]] > 1: # 한번보다 더 발견됐다 = 뒤에 더 있다
            gem_dict[gems[start]] -= 1 # 시작점 이동할 거니까 발견 값 하나 빼줌
            start += 1 # 시작점 한칸 이동
        elif (end - start) < section: # 이렇게 갱신한 범위가 이전에 찾은 범위보다 작으면?
            section = end - start 
            answer = [start + 1, end] # 범위 갱신
            break
        else: break
```                
- 먼저 start 이용해서 시작점 위치의 보석이 1번보다 더 발견됐는지 검사함.
- 1번보다 더 발견됐으면 범위안에 같은 보석이 더 있다는 뜻이므로, start 한칸 이동시키고 해당 보석 발견 횟수 다시 1 줄임.
- 이렇게 갱신된 start와 end의 범위가 이전에 찾은 범위보다 짧다면 answer 갱신.
- 시간복잡도 O(N*logN)?

## Review
처음에 풀고나서 맞을 줄 알았는데 효율성 통과를 못해서 결국 다른 코드 참고했다.. 투 포인터 알고리즘을 처음 푼 거라서 많이 헤맸다. 백준에 투 포인터 더 풀어봐야겠다.
