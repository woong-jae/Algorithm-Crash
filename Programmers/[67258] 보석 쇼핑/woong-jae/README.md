# [67258] 보석 쇼핑
## Algorithm
- Set
## Logic
### 첫 구현: O(N^2)
각 인데스마다 만들 수 있는 최소 구간을 구한다.

`Set`에 index부터 원소를 계속 넣다가, 보석 종류와 `Set` 사이즈가 같아지면 `answer`와 비교해 넣어준다.

이 알고리즘은 각 인덱스마다 최소구간을 구하기 때문에 굉장히 비효율적이다. 이것을 최적화할 수 있는 방법은 위에 적은 알고리즘에서 찾을 수 있다.

'각 인덱스마다' 만들 수 있는 '최소 구간을 구한다'. 즉, 다음에 시작할 인덱스를 구하는 것과 최소 구간을 찾는 것을 최적화해야한다.

### 최적화: O(NlogN)?
최적화하기 위해 정보를 얻어야한다. 처음 0번째 인덱스에서 최소 구간을 찾을 때 알아낸 정보를 활용할 것이다.

처음 최소구간을 알아낸 후 알 수 있는 정보는 '시작점', '끝점'이다. 그리고 끝점 보석은 현재 구간 내에서 중복되지 않는다.

여기서 먼저 현재 최소구간안에 더 짧은 최소구간이 있을 수 있기 때문에, '끝점'부터 '시작점'까지 가면서 더 가까운 시작점을 찾아준다.
시작점을 갱신했기 때문에 이제 시작점 보석도 구간에서 중복되지 않는다.

시작점 보석은 중복되지 않기 때문에, 시작점 다음부터 끝점까지는 `보석의 종류 - 1`개의 종류가 있다는 것을 알 수 있다.
따라서 다음 시작점은 `시작점 + 1`로 하고 탐색은 `끝점 + 1`부터 시작해서 다시 모든 보석의 종류가 있을 때까지 구간을 끝점을 갱신해주면 된다.

이것을 만족하는 구간이 없어질 때까지 반복하면 된다.

```js
let start = 0, cur = 0, picked = new Set();
while(start < gems.length) {
    while(cur < gems.length && picked.size < kind) { // 끝점 찾기
        picked.add(gems[cur++]);
    }
    if(picked.size === kind) { // 구간을 찾았음
        let end = --cur;
        // 더 가까운 시작점 찾기
        picked.clear();
        while(picked.size < kind) picked.add(gems[cur--]);
        start = cur + 1;
        // 찾은 구간이 더 짧다면 answer를 갱신
        if(answer[1] - answer[0] > end - start) {
            answer = [start, end];
            if(end - start + 1 === kind) break;
        }
        picked.delete(gems[start++]);
        cur = end + 1;
    }
    else break;
}
```

## Review
한 번도 풀어본 적이 없는 유형이여서 고민을 좀 했다.
이전 정보를 활용한다는 아이디어는 빨리 생각해냈지만, 어떻게 활용해야할지는 조금 더 생각한 후 알아낼 수 있었다.

뭔가 이전 정보를 활용한다는 점에서 KMP 알고리즘과 바슷하다고 생각이 드는 문제다.