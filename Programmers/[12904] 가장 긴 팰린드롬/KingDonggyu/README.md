# [12904] 가장 긴 팰린드롬

## Algorithm

- Dynamic Programming

## Logic

주어진 `s`와 `s`를 뒤집은 문자열에 대해 **가장 긴 부분 문자열(LCS)**를 구한다.

- 0으로 초기화된 2차원 배열 `dp`를 생성하고, 두 문자열의 단어가 같은 경우 아래 연산을 수행한다.

  ```js
  dp[x][y] = !x || !y ? 1 : dp[x - 1][y - 1] + 1;
  ```

  - `x` 또는 `y`가 0인 경우 1을 넣는다.

  - 그렇지 않을 경우, 왼쪽 위 대각선 값의 +1 한 값을 넣는다.

- 이를 반복하여 LCS의 길이를 리턴하면 된다.

<br />

하지만 이렇게 하면 팰린드롬이 아닌 문자열이 LCS로 선정될 가능성이 생긴다.

- 따라서 `answer`(LCS의 길이)가 업데이트되어야 할 때마다 아래 연산을 수행한다.

  ```js
  if (answer < dp[x][y] && isPalindrome(s, x, dp[x][y])) {
    answer = dp[x][y];
  }
  ```

  - `answer`보다 큰 길이의 부분 문자열이 나타나면, 해당 부분 문자열이 팰린드롬인지 확인을 거친 후 `answer`을 업데이트하는 것이다.

  - 이때, 팰린드롬인지 확인하는 방법이 시간초과의 주범이 된다. 따라서 인덱스를 이용한다.

    ```js
    function isPalindrome(s, right, length) {
      let left = right - length + 1;
      while (left < right) {
        if (s[left++] !== s[right--]) {
          return false;
        }
      }
      return true;
    }
    ```

    - 시작 인덱스와 끝 인덱스를 점점 좁혀오며 확인하며, 두 문자가 다를시 곧바로 `false`를 리턴한다.

### 시간 복잡도 : O(N^2logN)

## Review

LCS를 구하는 아이디어를 금방 떠올렸지만, 3번과 19번 테스트 케이스가 틀린 결과가 나왔다.

개선 요소를 고민하다 팰린드롬이 아닌 문자열이 LCS로 선정되는 반례를 찾았다.

그래서 `answer` 업데이트마다 팰린드롬인지 확인하는 부분을 추가했더니 효율성에서 시간초과..

팰린드롬인지 확인하는 방법으로 `slice`와 `reverse` 메서드를 활용했었는데, 이를 인덱스를 이용하는 방법으로 개선하니 통과할 수 있었다.