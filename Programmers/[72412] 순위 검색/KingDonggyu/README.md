# [72412] 순위 검색

## Algorithm

- Binary Search

- Map

## Logic

**1. info를 순회하며 각 원소를 다음과 같은 형태로 만들어 Map에 추가한다.**

- ex) 'java backend junior pizza 150' -> key: 'jbjp', value: `[150]`

- 이때 '-'가 들어갈 수 있는 모든 경우의 key에 대해 전부 Map에 추가한다.

  - ex) 'jbjp' -> '-bjp', 'j-bjp', 'jb--', '---p', '----' 등

- 이미 Map에 해당 key가 있는 경우 value 배열에 점수를 추가한다.

**2. 생성한 Map의 각 value를 오름차순으로 정렬한다.**

**3. query를 순회하며 각 원소를 생성한 Map에 검색할 수 있는 key로 만든 후 검색한다.**

- 만약 Map에 해당 key가 없는 경우 `answer` 배열에 0을 추가한다.

- key가 있다면 해당 value 배열에 대한 이진 탐색을 통해 query 원소의 점수보다 크거나 같은 값이 위치한 가장 첫 인덱스를 찾는다.

- value 배열의 길이에 찾은 인덱스를 뺀 값을 `answer` 배열에 추가한다.

## Review

처음에는 무지성으로 트리를 만들었다. 

그러자 효율성에서 탈락.

그러다 info의 한 원소에 대한 모든 경우의 수('-'를 고려한)가 16인 것을 보고, Map을 사용하는 아이디어를 떠올렸다.

그럼에도 효율성에서 탈락.

효율성 개선 요소에 대해 고민하다 이진 탐색을 적용해 보았더니 통과.

오래 걸렸다..