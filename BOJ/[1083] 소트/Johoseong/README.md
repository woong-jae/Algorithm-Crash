# [1083] 소트
## Algorithm
- 그리디
## Logic
### 처음 풀이
- 이중 for문으로 두 숫자 비교하면서 더 큰거를 앞으로 당기는 식으로 했는데 바로 틀렸습니다 떴음..
### 현재 풀이
- 핵심은, 현재 숫자에서 이동 범위 S 만큼만 뒤에 숫자를 탐색한 후, 그 중에서 가장 큰 숫자를 현재 숫자와 바꾸는 것임. 단순하게 두 숫자 비교해서 교환하면 예외 발생함.
1. 숫자 배열을 탐색하면서
2. 현재 숫자에서 뒤로 S만큼 탐색
3. 가장 큰 숫자를 기억해뒀다가, 그 숫자와 현재 숫자를 바꿈 (앞으로 당김)
```python
for j in range(i + 1, min(N, i + 1 + S)):
    if tmp_max < arr[j]:
        tmp_max = arr[j]
        index = j
    S -= index - i
    for j in range(index, i, -1):
        arr[j] = arr[j - 1]
    arr[i] = tmp_max
```
- 시간복잡도 O(N^2).

## Review
처음 풀이가 맞는 줄 알고 계속 삽질하다가 결국 다른 풀이 봤다. 그리디는 정말 다양한 것 같다.. 많이 풀어봐야겠다.
