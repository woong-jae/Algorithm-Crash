# [1562] 계단 수

## Algorithm
- 비트마스킹
- DP

## Logic

```java
for (int i = 2; i < N + 1; i++) {
    for (int end = 0; end < 10; end++) {
        for (int k = 0; k < 1024; k++) {
            int b = k | (1 << end);

            if (end == 0) {
                dp[i][end][b] = (dp[i][end][b] + dp[i - 1][end + 1][k]) % mod;
            } else if (end == 9) {
                dp[i][end][b] = (dp[i][end][b] + dp[i - 1][end - 1][k]) % mod;
            } else {
                dp[i][end][b] = (dp[i][end][b] + dp[i - 1][end + 1][k] + dp[i - 1][end - 1][k]) % mod;
            }
        }
    }
}
```

- `b` 는 현재 상태 `k`에 끝자리가 `end`인 상태를 추가한 비트를 의미한다.
  - 여기서 `k`는 0부터 1023까지의 값을 가지고, 0은 아무것도 포함하지 않은 숫자, 1023은 0~9까지 모두 포함한 숫자를 의미한다.
- 0과 9의 경우는 가능한 계단 수가 1개이므로, 해당하는 경우에 대한 점화식을 사용한다.

## :black_nib: **Review**

- 첫 시도는 start, end field를 가지는 클래스를 하나 생성하고, Set를 이용해 만들어지는 계단 수의 앞자리와 뒷자리 숫자를 저장하고, 저장한 앞, 뒷자리 숫자에 따라 다음 i + 1 길이의 앞, 뒷 자리 숫자를 또 저장하도록 했다.
- 메모리 초과가 발생했고, 0 ~ 9까지가 포함되었는지를 확인하는 로직을 이용해야겠다싶었고, boolean으로 해야하나 .. 하다가 시간을 너무 많이 써서 풀이를 참고하니 비트마스킹이었다.
  - boolean으로 매번 확인하는 것은 시간과 메모리가 많이 발생하니까 비트마스킹에 익숙해져서 이를 활용할 줄 알아야 한다.