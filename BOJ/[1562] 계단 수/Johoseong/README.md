# [1562] 계단 수
## Algorithm
- DP, BitMask
## Logic
### 처음 풀이
N=10인 ```9876543210```에서 숫자 붙여나가는 식으로 생각했는데 답이 없었다.. 
### 현재 풀이
- DP 배열을 3차원으로 ```DP[N 길이][마지막 숫자][사용된 숫자 Bitmask]``` 라고 두고 풀어야함.
- (이유) N+1 길이 기준으로 계단 수를 구해보자. 길이가 N인 계단 수들에서 마지막 숫자에 +1, -1 한 숫자를 붙인다. 이 중에서 사용된 숫자 Bitmask가 1023 (2^0+2^1+...+2^9 == 0~9의 모든 숫자가 쓰임)인 것들을 구하면 됨.
- 그래서 마지막 숫자와 0~9의 모든 숫자를 사용했는지 알아야하므로 Bitmask를 기억해둬야함.

```python
...
    if last == 9:
        dp[length + 1][8][bit | (1 << 8)] += dp[length][last][bit]
        dp[length + 1][8][bit | (1 << 8)] %= 1000000000
    elif last == 0:
        dp[length + 1][1][bit | (1 << 1)] += dp[length][last][bit]
        dp[length + 1][1][bit | (1 << 1)] %= 1000000000
    else: # 마지막이 1~8이면 +-1 가능
        dp[length + 1][last + 1][bit | (1 << (last + 1))] += dp[length][last][bit]
        dp[length + 1][last - 1][bit | (1 << (last - 1))] += dp[length][last][bit]
        dp[length + 1][last + 1][bit | (1 << (last + 1))] %= 1000000000
        dp[length + 1][last + 1][bit | (1 << (last - 1))] %= 1000000000
...
```
1. 마지막 숫자가 9인 경우: -1한 8만 추가 가능
2. 마지막 숫자가 0인 경우: +1한 1만 추가 가능
3. 마지막 숫자가 1~8인 경우: -1과 +1한 숫자 모두 추가 가능

## Review
DP는 어렵게 나오면 진짜 못 풀겠다;; 비트마스크 쓸 생각을 해도 접근을 못함.. DP 열심히 해야지..