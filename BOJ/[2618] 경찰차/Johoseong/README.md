# [2618] 경찰차
## Algorithm
- DP
## Logic
일단 틀렸다. 사람들이 정리해 둔 반례 모아둔 케이스 넣어보면 최단 거리는 잘 구하는데 경찰차 이동 경로가 조금 다름. 아마 누적값 + 경찰차1이 출동하는 것과 2가 출동하는 것이 같은 값을 가질 때를 또 고려해줘야할 듯.. (지금 코드는 두 값 같으면 2가 출동함)
- `DP[사건 i][경찰차 번호] = [i - 1에서 경찰차1의 위치, i - 1에서 경찰차2의 위치, 누적 최솟값]`을 DP로 뒀음. so, `W * 2 * 3` 크기의 Dp임
1. i번째 사건에서, 경찰차 1이 출동하는 경우 : `i - 1 사건을 1이 출동했을 때 누적이동 + 1의 사건 i까지 거리`와 `i - 1 사건을 2이 출동했을 때 누적이동 + 1의 사건 i까지 거리`
2. i번째 사건에서, 경찰차 2이 출동하는 경우 : `i - 1 사건을 1이 출동했을 때 누적이동 + 2의 사건 i까지 거리`와 `i - 1 사건을 2이 출동했을 때 누적이동 + 2의 사건 i까지 거리`
- 이동 경로는 현재 출동하는 경찰차가 무엇이냐에 따라 answer에 i - 1까지의 값을 복사 후 추가해나감
```python
    if dp[i - 1][1][0] == 0: # 1.
        past1_cur1 = dp[i - 1][1][2] + calc(police1, [r, c])
    else:
        past1_cur1 = dp[i - 1][1][2] + calc(events[dp[i - 1][1][0]], [r, c])
    if dp[i - 1][2][0] == 0:
        past2_cur1 = dp[i - 1][2][2] + calc(police1, [r, c])
    else:
        past2_cur1 = dp[i - 1][2][2] + calc(events[dp[i - 1][2][0]], [r, c])

    if past1_cur1 < past2_cur1:
        dp[i][1][0] = i
        dp[i][1][1] = dp[i - 1][1][1]
        dp[i][1][2] = past1_cur1
        tmp1 = copy.deepcopy(answer[1])
        tmp1.append(1)
    else:
        dp[i][1][0] = i
        dp[i][1][1] = dp[i - 1][2][1]
        dp[i][1][2] = past2_cur1
        tmp1 = copy.deepcopy(answer[2])
        tmp1.append(1)
...
```

## Review
최소 이동값만 출력하면 맞을 것 같은데 아쉽다.. 두 경찰차 이동값이 같을 때 무엇을 출동시킬지 결정하는 과정이 내 풀이에선 없음. (그냥 2 출동함) 어려웠다.